#!/usr/bin/env bash
# Usage: {script} OPTIONS
#
#   --help, -h      Displays this help
#   --version, -V   Displays the script version
#   --upgrade, -u   Upgrade deploy script
#
#   --env, -e       Environment to deploy
#   --config, -c    Displays configuration information
#   --remote, -r    Git remote name (default "origin")
#   --tree-ish, -i  Tree-Ish (branch or tag name, default "master")
#   --type, -t      Type of deploy ("upgrade" or "rollback")
#   --verbose, -v   Enable verbose mode
#   --yes, -y       Performs the deployment without asking
#
# Report bugs to Henrique Moody <henriquemoody@gmail.com>
#

declare -r SCRIPT=$(readlink "${0}" 2> /dev/null || echo "${0}")
declare -r SCRIPT_NAME=$(basename ${0})
declare -r SCRIPT_PID=$(echo ${$})
declare -r ROOT_DIRECTORY=$(cd "$(dirname "${SCRIPT}")/.." && pwd)
declare -r SETTINGS_DIRECTORY=$(test "$(whoami)" = "root" && echo "/etc/deployer" || echo "${HOME}/.deployer")

declare -r APPLICATION_CONFIG="${SETTINGS_DIRECTORY}/default.conf"
declare -r APPLICATION_SOURCE="${SETTINGS_DIRECTORY}/var/source"
declare -r DATETIME=$(date '+%Y-%m-%d %H:%M:%S')
declare -r DELIMITER=":"
declare -r DEPLOY_USER=$(test ! -z "${SUDO_USER}" && echo "${SUDO_USER}" || whoami)
declare -r LOCAL_ADDRESS=$(hostname)
declare -r TIMESTAMP=$(date '+%s')

declare DEPLOY_TYPE="upgrade"
declare ENVIRONMENT="live"
declare GIT_REMOTE="origin"
declare GIT_TREE_ISH="master"
declare VERBOSE=""
declare YES=0

## -------------------------------------------------------------------------- ##
source "${ROOT_DIRECTORY}/src/check/access.bash"
source "${ROOT_DIRECTORY}/src/conf/get.bash"
source "${ROOT_DIRECTORY}/src/conf/read.bash"
source "${ROOT_DIRECTORY}/src/conf/set.bash"
source "${ROOT_DIRECTORY}/src/conf/show.bash"
source "${ROOT_DIRECTORY}/src/deploy/cleanup.bash"
source "${ROOT_DIRECTORY}/src/deploy/finish.bash"
source "${ROOT_DIRECTORY}/src/deploy/prepare.bash"
source "${ROOT_DIRECTORY}/src/deploy/prepare/rollback.bash"
source "${ROOT_DIRECTORY}/src/deploy/prepare/upgrade.bash"
source "${ROOT_DIRECTORY}/src/echo.bash"
source "${ROOT_DIRECTORY}/src/help.bash"
source "${ROOT_DIRECTORY}/src/lock/create.bash"
source "${ROOT_DIRECTORY}/src/lock/remove.bash"
source "${ROOT_DIRECTORY}/src/log.bash"
source "${ROOT_DIRECTORY}/src/ssh.bash"

## -------------------------------------------------------------------------- ##
while [[ "${1}" = -* ]]; do
    case "${1}" in

        --help | -h)
            _help
            exit 0
        ;;

        --version | -V)
            cd "${ROOT_DIRECTORY}"
            git describe
            exit 0
        ;;

        --upgrade | -u)
            cd "${ROOT_DIRECTORY}"
            git pull
            exit 0
        ;;

        --env | -e)
            ENVIRONMENT="${2}"
            shift 2
        ;;
        *)
            break
        ;;
    esac
done

## -------------------------------------------------------------------------- ##
if [[ ! -f "${APPLICATION_CONFIG}" ]]; then
    if [ ! -t 1 ]; then
        _echo "<31>You do not have configuration file, please run it in an interactive shell first.<0>" 1>&2
        exit 3
    fi

    if [[ ! -d "${SETTINGS_DIRECTORY}" ]]; then
        mkdir -p "${SETTINGS_DIRECTORY}"
        test ${?} -gt 0 &&
            _echo "<31>Unable to create directory \"${SETTINGS_DIRECTORY}\".<0>" 1>&2 &&
            exit 4
    fi

    if [[ ! -w "${SETTINGS_DIRECTORY}" ]]; then
        _echo "<31>\"${SETTINGS_DIRECTORY}\" is not a valid writable.<0>" 1>&2
        exit 5
    fi

    mkdir -p "${SETTINGS_DIRECTORY}/var/log"
    cp -r "${ROOT_DIRECTORY}/etc/"* "${SETTINGS_DIRECTORY}/"

    _echo -n "<32>First time running this script? Please fill the data below:<0>"
    _echo

    _echo -n "<33>Application's name:<0> "
    read InputName
    test -z "${InputName}" &&
        _echo "<31>Application's name can not be empty<0>" 1>&2 &&
        exit 6

    _echo -n "<33>Remote application's directory:<0> "
    read InputDirectory
    test -z "${InputDirectory}" &&
        _echo "<31>Application's remote directory can not be empty<0>" 1>&2 &&
        exit 7

    _echo -n "<33>Application's GIT repository:<0> "
    read InputRepository
    test -z "${InputRepository}" &&
        _echo "<31>Application's GIT repository can not be empty<0>" 1>&2 &&
        exit 8

    if [[ -d "${APPLICATION_SOURCE}" ]]; then
        rm -rf "${APPLICATION_SOURCE}"
    fi
    git clone --quiet "${InputRepository}" "${APPLICATION_SOURCE}"
    if [[ ${?} -gt 0 ]]; then
        _echo "<31>Unable to clone GIT repository<0>" 1>&2
        exit 9
    fi

    _echo -n "<33>File system owner (default \"<0>www-data<33>\"):<0> "
    read InputFileSystemOwner
    if [[ -z "${InputFileSystemOwner}" ]]; then
       InputFileSystemOwner="www-data"
    fi

    id "${InputFileSystemOwner}" > /dev/null 2>&1
    if [[ ${?} -gt 0 ]]; then
        _echo "<31>User ${InputFileSystemOwner} does not exists<0>" 1>&2
        exit 10
    fi

    _echo -n "<33>File system group (default \"<0>www-data<33>\"):<0> "
    read InputFileSystemGroup
    if [[ -z "${InputFileSystemGroup}" ]]; then
       InputFileSystemGroup="www-data"
    fi

    _echo -n "<33>SSH connection timeout (default \"<0>5<33>\"):<0> "
    read InputSshConnectionTimeout
    if [[ -z "${InputSshConnectionTimeout}" ]]; then
       InputSshConnectionTimeout=5
    fi

    _echo -n "<33>SSH user (default \"<0>${DEPLOY_USER}<33>\"):<0> "
    read InputSshUser
    if [[ -z "${InputSshUser}" ]]; then
       InputSshUser="${DEPLOY_USER}"
    fi

    _echo -n "<33>SSH port (default \"<0>22<33>\"):<0> "
    read InputSshPort
    if [[ -z "${InputSshPort}" ]]; then
       InputSshPort="22"
    fi

    _echo -n "<33>SSH private key file (will use yours by default):<0> "
    read -e InputSshPrivateKeyFile

    _echo -n "<33>Do you want to enable New Relic notifications? [y/N]:<0> "
    read InputEnableNewRelicNotification
    InputEnableNewRelicNotification=$(echo "${InputEnableNewRelicNotification}" | tr [a-z] [A-Z])
    if [[ "${InputEnableNewRelicNotification}" = 'Y' ]]  || [[ "${InputEnableNewRelicNotification}" = 'YES' ]]; then
        InputNewRelicNotification="On"
        _echo -n "<33>  > Your New Relic API key:<0> "
        read InputNewRelicApiKey
        _echo -n "<33>  > Your New Relic application id:<0> "
        read InputNewRelicApplicationId
    else
        InputNewRelicNotification="Off"
        InputNewRelicApiKey=""
        InputNewRelicApplicationId=""
    fi

    _conf_set "Name" "${InputName}"
    _conf_set "Directory" "${InputDirectory}"
    _conf_set "Repository" "${InputRepository}"
    _conf_set "FileSystemOwner" "${InputFileSystemOwner}"
    _conf_set "FileSystemGroup" "${InputFileSystemGroup}"
    _conf_set "SshConnectionTimeout" "${InputSshConnectionTimeout}"
    _conf_set "SshUser" "${InputSshUser}"
    _conf_set "SshPort" "${InputSshPort}"
    _conf_set "SshPrivateKeyFile" "${InputSshPrivateKeyFile}"
    _conf_set "NewRelicNotification" "${InputNewRelicNotification}"
    _conf_set "NewRelicApiKey" "${InputNewRelicApiKey}"
    _conf_set "NewRelicApplicationId" "${InputNewRelicApplicationId}"
fi

declare -r ENVIRONMENT_CONFIG="${SETTINGS_DIRECTORY}/${ENVIRONMENT}.conf"
declare -r ENVIRONMENT_SERVERS="${SETTINGS_DIRECTORY}/${ENVIRONMENT}.servers"
declare -r ENVIRONMENT_OVERLAY="${SETTINGS_DIRECTORY}/${ENVIRONMENT}.overlay"

declare -r ENVIRONMENT_CURRENT="${SETTINGS_DIRECTORY}/var/${ENVIRONMENT}"
declare -r ENVIRONMENT_NEWEST="${SETTINGS_DIRECTORY}/var/${ENVIRONMENT}.newest"
declare -r ENVIRONMENT_OLDEST="${SETTINGS_DIRECTORY}/var/${ENVIRONMENT}.oldest"

## -------------------------------------------------------------------------- ##
while [[ "${1}" = -* ]]; do
    case "${1}" in

        --config | -c)
            _conf_show
            exit 0
        ;;

        --remote | -r)
            GIT_REMOTE="${2}"
            shift 2
        ;;

        --timeout | -m)
            SSH_CONNECTION_TIMEOUT="${2}"
            shift 2
        ;;

        --tree-ish | -i)
            GIT_TREE_ISH="${2}"
            shift 2
        ;;

        --type | -t)
            if [[ "${2}" != 'rollback' ]] && [[ "${2}" != 'upgrade' ]]; then
                _echo "<31>Argument '${1}' must be 'rollback' or 'upgrade'. See '--help' for more info.<0>" 1>&2
                exit 1
            fi

            DEPLOY_TYPE="${2}"
            shift 2
        ;;

        --verbose | -v)
            VERBOSE="v"
            shift 1
        ;;

        --yes | -y)
            YES=1
            shift 1
        ;;

        -*)
            _echo "<31>Unrecognized option '${1}'. Run '--help' for more info.<0>" 1>&2
            exit 2
        ;;

    esac
done

## -------------------------------------------------------------------------- ##
declare DEPLOY_CHANGELOG
declare DEPLOY_DESCRIPTION
declare DEPLOY_REVISION

declare SSH_CONNECTION_TIMEOUT=$(_conf_get "SshConnectionTimeout" "${APPLICATION_CONFIG}")
declare SSH_USER=$(_conf_get "SshUser" "${APPLICATION_CONFIG}")
declare SSH_PORT=$(_conf_get "SshPort" "${APPLICATION_CONFIG}")
declare SSH_PRIVATE_KEY_FILE=$(_conf_get "SshPrivateKeyFile" "${APPLICATION_CONFIG}")
declare SSH_OPTIONS=$(test ! -z ${SSH_PRIVATE_KEY_FILE} && echo "-i ${SSH_PRIVATE_KEY_FILE}")
        SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=${SSH_CONNECTION_TIMEOUT}"
        SSH_OPTIONS="${SSH_OPTIONS} -o PasswordAuthentication=no"
        SSH_OPTIONS="${SSH_OPTIONS} -o StrictHostKeyChecking=no"
        SSH_OPTIONS="${SSH_OPTIONS} -o UserKnownHostsFile=/dev/null"
        SSH_OPTIONS="${SSH_OPTIONS} -p ${SSH_PORT}"

declare DEPLOY_LOG_BASE="${SETTINGS_DIRECTORY}/var/log/${ENVIRONMENT}_${TIMESTAMP}"
declare DEPLOY_LOG_FILENAME="${DEPLOY_LOG_BASE}.log"
declare DEPLOY_LOCK_FILE="/var/run/deployer/${ENVIRONMENT}.pid"

declare APPLICATION_DIRECTORY=$(_conf_get Directory)
declare APPLICATION_GROUP=$(_conf_get FileSystemGroup)
declare APPLICATION_NAME=$(_conf_get Name)
declare APPLICATION_OWNER=$(_conf_get FileSystemOwner)
declare APPLICATION_REPOSITORY=$(_conf_get Repository)

## -------------------------------------------------------------------------- ##
_echo "<32;4>Deployer<0>"
_echo "<36>Deploying <36;1>${APPLICATION_NAME}<0><36> as <36;1>${DEPLOY_USER}<0>"
_echo
## -------------------------------------------------------------------------- ##

if [[ ${YES} -eq 1 ]]; then
    answer='YES'
elif [ -t 1 ]; then
    _echo -n "Are you sure that you want to deploy <32>${DEPLOY_TYPE}<0>"
    if [[ "${DEPLOY_TYPE}" == "upgrade" ]]; then
        _echo -n " from <32>${GIT_TREE_ISH}<0>"
    fi
    _echo -n " on <32>${ENVIRONMENT}<0> environment? [y/N]: "
    read answer
elif [[ ${YES} -eq 0 ]]; then
    _echo "<31>You can not run \`${SCRIPT_NAME}\` in non-interactive mode or pass '--yes/-y' option.<0>" 1>&2
    exit 12
fi

parsed_answer=$(echo ${answer} | tr '[:lower:]' '[:upper:]')
if [[ "${parsed_answer}" != 'Y' ]] && [[ "${parsed_answer}" != 'YES' ]]; then
    _echo "<31>Deploy aborted<0>" 1>&2
    exit 13
elif [ -f "${DEPLOY_LOCK_FILE}" ]; then
    _echo \
        "<31>A deploy on this environment is already running.<0>" \
        "<31>Wait or remove the lock file \`${DEPLOY_LOCK_FILE}\`<0>" 1>&2
    exit 14
fi

if [[ ! -f "${ENVIRONMENT_SERVERS}" ]]; then
    _echo "<31>Unable to find \"${ENVIRONMENT}.servers\" file<0>" 1>&2
    exit 22
fi

DEPLOY_DESCRIPTION="Deploy ${DEPLOY_TYPE} of ${GIT_TREE_ISH} on ${ENVIRONMENT}"

_echo

_echo -n "<32>Deploying \"${DEPLOY_TYPE}\"<0>"
if [[ "${DEPLOY_TYPE}" == "upgrade" ]]; then
    _echo -n "<32> from \"${GIT_TREE_ISH}\"<0>"
fi
_echo "<32> on \"${ENVIRONMENT}\" environment<0>"

_echo "\n<33>Checking superuser privileges<0>"
sudo mkdir -p "/var/run/deployer" > /dev/null
if [[ ${?} -gt 0 ]]; then
    _echo "<31>You don't have superuser privileges<0>" 1>&2
    exit 11
else
    _echo "<32>You have superuser privileges<0>"
fi

_lock_create

_log 'Starting deploy'

## -------------------------------------------------------------------------- ##
_echo "\n<33>Checking access to servers<0>"

PIDS=""
IS_ALLOWED=1
while read line; do
    test -z "${line}" && continue

    server_name=$(echo "${line}" | cut -d ${DELIMITER} -f 1)
    server_address=$(echo "${line}" | cut -d ${DELIMITER} -f 2)

    _check_access "${server_name}" "${server_address}" &
    PIDS="${PIDS} ${!}"

done < "${ENVIRONMENT_SERVERS}"

for PID in ${PIDS}; do
    test -z ${PID} &&
        continue

    wait ${PID}
    if [[ ${?} -gt 0 ]]; then
        IS_ALLOWED=0
    fi
done

test ${IS_ALLOWED} -eq 0 &&
    _echo "<31>Please, check your SSH key or server availability and try again later.<0>" 1>&2 &&
    _lock_remove &&
    exit 15

## -------------------------------------------------------------------------- ##

if [[ "${DEPLOY_TYPE}" == "upgrade" ]]; then

    ## ---------------------------------------------------------------------- ##
    _echo "\n<33>Fetching data from remote repository<0>"
    if [ ! -d "${APPLICATION_SOURCE}/.git" ]; then
        git clone "${APPLICATION_REPOSITORY}" "${APPLICATION_SOURCE}"
    fi
    cd "${APPLICATION_SOURCE}"
    git fetch "${GIT_REMOTE}"

    if [ -d "${ENVIRONMENT_NEWEST}" ]; then
        _echo "\n<33>Removing trash of some older deploy<0>"
        rm -rf "${ENVIRONMENT_NEWEST}"
    fi

    ## ---------------------------------------------------------------------- ##
    _echo "\n<33>Preparing application code<0>"

    _echo "* Creating new code"
    mkdir -p "${ENVIRONMENT_NEWEST}"

    git tag -l | egrep -q "^${GIT_TREE_ISH}$"
    if [[ ${?} -gt 0 ]]; then
        GIT_TREE_ISH="${GIT_REMOTE}/${GIT_TREE_ISH}"
    fi
    git archive "${GIT_TREE_ISH}" | tar -x -C "${ENVIRONMENT_NEWEST}"

    if [[ ${?} -gt 0 ]]; then
        _echo "<31>Failure creating new code<0>" 1>&2
        _lock_remove
        exit 16
    fi

    GIT_LOG=$(git log -n1 --format='format:%h|%aN <%ae>|%s' "${GIT_TREE_ISH}")
    GIT_LOG_HASH=$(echo "${GIT_LOG}" | cut -d '|' -f 1)
    GIT_LOG_AUTHOR=$(echo "${GIT_LOG}" | cut -d '|' -f 2)
    GIT_LOG_SUBJECT=$(echo "${GIT_LOG}" | cut -d '|' -f 3-)

    REV_CONTENT="Timestamp: ${TIMESTAMP}\n"
    REV_CONTENT="${REV_CONTENT}Date-Time: ${DATETIME}\n"
    REV_CONTENT="${REV_CONTENT}Tree-Ish:  ${GIT_TREE_ISH}\n"
    REV_CONTENT="${REV_CONTENT}Author:    ${GIT_LOG_AUTHOR}\n"
    REV_CONTENT="${REV_CONTENT}Commit:    ${GIT_LOG_HASH}\n"
    REV_CONTENT="${REV_CONTENT}Message:   ${GIT_LOG_SUBJECT}\n"

    _echo "${REV_CONTENT}" > "${ENVIRONMENT_NEWEST}/rev.txt"

    if [ -d "${ENVIRONMENT_OLDEST}" ]; then
        _echo "* Removing old code"
        sudo rm -rf "${ENVIRONMENT_OLDEST}"
    fi

    if [ -d "${ENVIRONMENT_CURRENT}" ]; then
        _echo "* Creating backup of current code"
        sudo mv "${ENVIRONMENT_CURRENT}" "${ENVIRONMENT_OLDEST}"
    fi

    _echo "* Replacing current code with the new code"
    mv "${ENVIRONMENT_NEWEST}" "${ENVIRONMENT_CURRENT}"

    cd "${OLDPWD}"
    cd "${ENVIRONMENT_CURRENT}"

    test -f "${SETTINGS_DIRECTORY}/default.hooks/local-pre" &&
        cp "${SETTINGS_DIRECTORY}/default.hooks/local-pre" "${ENVIRONMENT_CURRENT}/local-pre-default.hook"
    test -f "${SETTINGS_DIRECTORY}/default.hooks/remote-pre" &&
        cp "${SETTINGS_DIRECTORY}/default.hooks/remote-pre" "${ENVIRONMENT_CURRENT}/remote-pre-default.hook"
    test -f "${SETTINGS_DIRECTORY}/default.hooks/remote-post" &&
        cp "${SETTINGS_DIRECTORY}/default.hooks/remote-post" "${ENVIRONMENT_CURRENT}/remote-post-default.hook"

    test -f "${SETTINGS_DIRECTORY}/${ENVIRONMENT}.hooks/local-pre" &&
        cp "${SETTINGS_DIRECTORY}/${ENVIRONMENT}.hooks/local-pre" "${ENVIRONMENT_CURRENT}/local-pre-env.hook"
    test -f "${SETTINGS_DIRECTORY}/${ENVIRONMENT}.hooks/remote-pre" &&
        cp "${SETTINGS_DIRECTORY}/${ENVIRONMENT}.hooks/remote-pre" "${ENVIRONMENT_CURRENT}/remote-pre-env.hook"
    test -f "${SETTINGS_DIRECTORY}/${ENVIRONMENT}.hooks/remote-post" &&
        cp "${SETTINGS_DIRECTORY}/${ENVIRONMENT}.hooks/remote-post" "${ENVIRONMENT_CURRENT}/remote-post-env.hook"

    _echo "* Applying overlays"
    export LC_ALL=C
    cat "${ENVIRONMENT_OVERLAY}" |
        egrep -v '^(#.+|\s*)$' |
        sed -e 's/\\:/\d255/g' |
        while read line; do
            variable=$(echo "${line}" | cut -d : -f 1)
            value=$(echo "${line}" | cut -d : -f 2 | sed -e 's/\d255/\\:/g')
            patterns=$(echo "${line}" | cut -d : -f 3)
            IFS='|'
            for pattern in ${patterns}; do
                find . -name "${pattern}" -print0 | sudo xargs -0 sed -i "s:${variable}:${value}:g"
            done
            IFS=' '
        done

    _echo "* Running pre hooks"

    HOOK_DEBUG=$(test ! -z "${VERBOSE}" && echo '-x')

    if [ -f "local-pre-default.hook" ]; then
        _log "Running local-pre-default.hook"
        sh ${HOOK_DEBUG} "local-pre-default.hook" >> "${DEPLOY_LOG_FILENAME}" 2>&1
        if [[ ${?} -gt 0 ]]; then
            _echo "<31>An error occurred running \`local-pre-default.hook\`.<0>" 1>&2
            tail "${DEPLOY_LOG_FILENAME}"
            _lock_remove
            exit 17
        fi
        _log "Finished local-pre-default.hook"
    fi

    if [ -f "local-pre-env.hook" ]; then
        _log "Running local-pre-env.hook"
        sh ${HOOK_DEBUG} "local-pre-env.hook" >> "${DEPLOY_LOG_FILENAME}" 2>&1
        if [[ ${?} -gt 0 ]]; then
            _echo "<31>An error occurred running \`local-pre-env.hook\`.<0>" 1>&2
            tail "${DEPLOY_LOG_FILENAME}"
            _lock_remove
            exit 18
        fi
        _log "Finished local-pre-env.hook"
    fi

    _echo "* Defining file system owner and group"
    sudo chown -R "${APPLICATION_OWNER}:${APPLICATION_GROUP}" "${ENVIRONMENT_CURRENT}" >> "${DEPLOY_LOG_FILENAME}" 2>&1
    if [[ ${?} -gt 0 ]]; then
        _echo '<31>Failure when defining file system owner and group<0>' 1>&2
        tail "${DEPLOY_LOG_FILENAME}"
        _lock_remove
        exit 21
    fi

    cd "${OLDPWD}"

    DEPLOY_REVISION="${GIT_LOG_HASH}"
    DEPLOY_CHANGELOG="${GIT_LOG_AUTHOR}: ${GIT_LOG_SUBJECT}"
else
    DEPLOY_REVISION=$(cat "${ENVIRONMENT_OLDEST}/rev.txt" | grep Commit | cut -d ' ' -f 2-)
    DEPLOY_CHANGELOG=$(cat "${ENVIRONMENT_OLDEST}/rev.txt" | grep Message | cut -d ' ' -f 2-)
fi

## -------------------------------------------------------------------------- ##
_echo "\n<33>Syncing code on servers<0>"
PIDS=""
IS_SYNCED=1
DEPLOY_DESCRIPTION="${DEPLOY_DESCRIPTION}. Servers:"
while read line; do
    test -z "${line}" && continue

    server_name=$(echo "${line}" | cut -d ${DELIMITER} -f 1)
    server_address=$(echo "${line}" | cut -d ${DELIMITER} -f 2)

    _deploy_prepare "${server_name}" "${server_address}" &
    PIDS="${PIDS} ${!}"

    DEPLOY_DESCRIPTION="${DEPLOY_DESCRIPTION} ${server_name} (${server_address}),"

done < "${ENVIRONMENT_SERVERS}"

for PID in ${PIDS}; do
    test -z ${PID} &&
        continue

    wait ${PID}
    if [[ ${?} -gt 0 ]]; then
        IS_SYNCED=0
    fi
done

test ${IS_SYNCED} -eq 0 &&
    _echo "<31>An error occurred when syncing servers. Please check with the administrator.<0>" 1>&2 &&
    _lock_remove &&
    exit 19

DEPLOY_DESCRIPTION="${DEPLOY_DESCRIPTION} was successful done."

## -------------------------------------------------------------------------- ##
if [[ "$(_conf_get NewRelicNotification)" = "On" ]]; then
    _echo '\n<33>Sending New Relic deploy notification'

    curl \
        -H "x-api-key:$(_conf_get NewRelicApiKey)" \
        -d "deployment[application_id]=$(_conf_get NewRelicApplicationId)" \
        -d "deployment[host]=${LOCAL_ADDRESS}" \
        -d "deployment[description]=${DEPLOY_DESCRIPTION}" \
        -d "deployment[revision]=${DEPLOY_REVISION}" \
        -d "deployment[changelog]=${DEPLOY_CHANGELOG}" \
        -d "deployment[user]=${DEPLOY_USER}" \
        https://rpm.newrelic.com/deployments.xml > /dev/null
fi

## -------------------------------------------------------------------------- ##
_echo "\n<33>Deploying code on servers<0>"

PIDS=""
IS_DEPLOYED=1
while read line; do
    test -z "${line}" && continue

    server_name=$(echo "${line}" | cut -d ${DELIMITER} -f 1)
    server_address=$(echo "${line}" | cut -d ${DELIMITER} -f 2)

    _deploy_finish "${server_name}" "${server_address}" &
    PIDS="${PIDS} ${!}"

done < "${ENVIRONMENT_SERVERS}"

for PID in ${PIDS}; do
    test -z ${PID} &&
        continue

    wait ${PID}
    if [[ ${?} -gt 0 ]]; then
        IS_DEPLOYED=0
    fi
done

test ${IS_DEPLOYED} -eq 0 &&
    _echo "<31>An error occurred when deploying to servers. Please check with the administrator.<0>" 1>&2 &&
    _lock_remove &&
    exit 20

## -------------------------------------------------------------------------- ##
_log 'Finished deploy'

## -------------------------------------------------------------------------- ##
_echo "\n<33>Cleaning code on servers<0>"

while read line; do
    test -z "${line}" && continue

    server_name=$(echo "${line}" | cut -d ${DELIMITER} -f 1)
    server_address=$(echo "${line}" | cut -d ${DELIMITER} -f 2)

    _deploy_cleanup "${server_name}" "${server_address}" &

done < "${ENVIRONMENT_SERVERS}"

wait

## -------------------------------------------------------------------------- ##
_echo "\n<33>Successful on deploying!<0>"
_echo "* Application:   ${APPLICATION_NAME}"
_echo "* Environment:   ${ENVIRONMENT}"
_echo "* Started at:    ${DATETIME}"
_echo "* Finished at:   $(date '+%Y-%m-%d %H:%M:%S')"
_echo "* Tree-Ish:      ${GIT_TREE_ISH}"
_echo "* Type:          ${DEPLOY_TYPE}"

_lock_remove
